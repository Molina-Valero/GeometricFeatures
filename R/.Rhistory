points = as.matrix(tree),
dist = 0.1,
Verticality = TRUE,
Planarity = TRUE,
num_threads = 1
)
})
print(time_taken)
write.table(features, "../data/treeFeatures.txt", row.names = FALSE)
summary(features)
str(features)
str(tree)
# Compile the C++ code
sourceCpp("../src/geometric_features_updated.cpp")
library(Rcpp)
library(FNN)  # For k-nearest neighbor search
# ===== Example 1: Using the original distance-based function =====
# This is your existing workflow - unchanged
cat("Example 1: Original distance-based approach\n")
cat("=" %R% 40, "\n\n")
# Generate sample point cloud
set.seed(123)
n <- 1000
xyz_full <- matrix(rnorm(n * 3), ncol = 3)
colnames(xyz_full) <- c("x", "y", "z")
# Select points to compute features for
query_points <- cbind(
point = 1:10,
xyz_full[1:10, ]
)
# Compute features using distance-based approach
result_dist <- geometric_features(
points = query_points,
x_all = xyz_full[, 1],
y_all = xyz_full[, 2],
z_all = xyz_full[, 3],
dist = 0.5,
num_threads = 2
)
print(head(result_dist))
# ===== Example 2: Using the new k-NN CSR-based function =====
cat("\n\nExample 2: New k-NN CSR-based approach\n")
cat("=" %R% 40, "\n\n")
# Step 1: Compute k-nearest neighbors for all points
k <- 30  # number of neighbors
knn_result <- FNN::get.knn(xyz_full, k = k)
# Flatten the neighbor indices (convert to 0-based indexing for C++)
nn <- as.integer(as.vector(t(knn_result$nn.index)) - 1)
# Create pointer array
nn_ptr <- as.integer(seq(0, length(nn), by = k))
# Step 3: Select which points to compute features for
point_indices <- 1:10  # Compute features for first 10 points
# Step 4: Compute features using k-NN approach
result_knn <- geometric_features_knn(
xyz = xyz_full,
nn = nn,
nn_ptr = nn_ptr,
point_indices = point_indices,
k_nn = k,
num_threads = 2
)
print(head(result_knn))
# ===== Example 3: Comparison of results =====
cat("\n\nExample 3: Comparing both approaches\n")
cat("=" %R% 40, "\n\n")
# Compare normal vectors (should be similar if neighborhoods overlap)
comparison <- data.frame(
point = result_dist$point[1:5],
dist_normal_z = result_dist$Normal_z[1:5],
knn_normal_z = result_knn$Normal_z[1:5],
diff = abs(result_dist$Normal_z[1:5] - result_knn$Normal_z[1:5])
)
print(comparison)
# ===== Example 4: Advanced - Variable k per point =====
cat("\n\nExample 4: Variable k per point (advanced)\n")
cat("=" %R% 40, "\n\n")
cat("Variable k approach requires custom CSR construction.\n")
cat("See documentation for details.\n")
# ===== Performance Notes =====
cat("\n\nPerformance Notes:\n")
cat("=" %R% 40, "\n")
cat("1. k-NN approach is faster when:\n")
cat("   - Computing features for many/all points\n")
cat("   - Using same k for all points\n")
cat("   - Neighbors can be pre-computed once\n\n")
cat("2. Distance approach is better when:\n")
cat("   - Computing features for few query points\n")
cat("   - Need variable search radius\n")
cat("   - Working with sparse queries\n\n")
# ===== Helper function: Create CSR from custom neighbors =====
create_csr_format <- function(neighbor_list) {
# neighbor_list: list where neighbor_list[[i]] contains neighbor indices for point i
# Returns: list with 'nn' and 'nn_ptr' in CSR format
n_points <- length(neighbor_list)
# Flatten all neighbors
nn <- unlist(neighbor_list)
# Create pointer array
nn_ptr <- c(0, cumsum(sapply(neighbor_list, length)))
return(list(
nn = as.integer(nn - 1),  # Convert to 0-based indexing
nn_ptr = as.integer(nn_ptr)
))
}
# Example usage of helper function
neighbor_list <- list(
c(2, 3, 5),      # neighbors of point 1
c(1, 4, 6),      # neighbors of point 2
c(1, 5, 7)       # neighbors of point 3
# ... etc
)
csr <- create_csr_format(neighbor_list)
cat("\nCSR format example:\n")
cat("nn:", csr$nn, "\n")
cat("nn_ptr:", csr$nn_ptr, "\n")
xyz_full
xyz_full
tree
nn
nn_ptr
point_indices
k
library(Rcpp)
# Compile the C++ code
sourceCpp("../src/geometric_features_knn.cpp")
# Generate sample point cloud
set.seed(123)
n <- 1000
xyz_full <- matrix(rnorm(n * 3), ncol = 3)
colnames(xyz_full) <- c("x", "y", "z")
# Select points to compute features for
query_points <- cbind(
point = 1:10,
xyz_full[1:10, ]
)
# =========================
# NOW (k-NN based):
# =========================
result <- geometric_features(
points = query_points,
x_all = xyz_full[, 1],
y_all = xyz_full[, 2],
z_all = xyz_full[, 3],
k = 30,               # <-- k neighbors parameter (CHANGED!)
num_threads = 2
)
print(head(result))
query_points
tree
xyz_full[, 1]
# =========================
# NOW (k-NN based):
# =========================
result <- geometric_features(
points = tree,
x_all = tree$x,
y_all = tree$y,
z_all = tree$z,
k = 30,               # <-- k neighbors parameter (CHANGED!)
num_threads = 2
)
# =========================
# NOW (k-NN based):
# =========================
result <- geometric_features(
points = as.matrix(tree),
x_all = tree$x,
y_all = tree$y,
z_all = tree$z,
k = 30,               # <-- k neighbors parameter (CHANGED!)
num_threads = 2
)
print(head(result))
summary(result)
# Compile the C++ code
sourceCpp("../src/geometric_features.cpp")
# Compile the C++ code
sourceCpp("../src/geometric_features_dist.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
# Calculate features within radius of 2 units
time_taken <- system.time({
features <- geometric_features(
points = as.matrix(tree),
dist = 1,
Verticality = TRUE,
Planarity = TRUE,
num_threads = 1
)
})
print(time_taken)
features
summary(features)
# Calculate features within radius of 2 units
time_taken <- system.time({
features <- geometric_features(
points = as.matrix(tree),
dist = 2,
Verticality = TRUE,
Planarity = TRUE,
num_threads = 1
)
})
# Compile the C++ code
sourceCpp("../src/geometric_features_updated.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
# Calculate features within radius of 2 units
time_taken <- system.time({
features <- geometric_features(
points = as.matrix(tree),
dist = 1,
Verticality = TRUE,
Planarity = TRUE,
num_threads = 1
)
})
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_ultra_dist.cpp")
# Calculate features within radius of 2 units
time_taken <- system.time({
features <- geometric_features(
points = as.matrix(tree),
dist = 1,
Verticality = TRUE,
Planarity = TRUE,
num_threads = 1
)
})
print(time_taken)
features
summary(features)
# Compile the C++ code
sourceCpp("../src/geometric_features_knn.cpp")
# Calculate features within radius of 2 units
time_taken <- system.time({
features <- geometric_features(
points = as.matrix(tree),
k = 30,
# dist = 1,
Verticality = TRUE,
Planarity = TRUE,
num_threads = 1
)
})
print(time_taken)
library(Rcpp)
# Compile the C++ code
sourceCpp("../src/geometric_features_dist.cpp")
sourceCpp("../src/geometric_features_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
time_taken <- system.time({
features <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.15,
Verticality = TRUE,
num_threads = 1
)
})
print(time_taken)
summary(features)
time_taken <- system.time({
features <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.15,
Verticality = TRUE,
num_threads = 10
)
})
time_taken <- system.time({
features <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.15,
Verticality = TRUE,
num_threads = 10
)
})
print(time_taken)
write.table(features, "../data/treeFeatures_dist.txt", row.names = FALSE)
# Test: Geometric features based on knn
# Calculate features within radius of 2 units
time_taken <- system.time({
features <- geometric_features_knn(
points = as.matrix(tree),
k = 30,
Verticality = TRUE,
num_threads = 10
)
})
print(time_taken)
write.table(features, "../data/treeFeatures_knn.txt", row.names = FALSE)
cat("\nTest completed successfully!\n")
time_taken <- system.time({
features <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.15,
Verticality = TRUE,
num_threads = 10
)
})
print(time_taken)
summary(features)
# Compile the C++ code
sourceCpp("../src/geometric_features_dist.cpp")
sourceCpp("../src/geometric_features_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
time_taken <- system.time({
features <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.15,
Verticality = TRUE,
num_threads = 10
)
})
print(time_taken)
features
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_dist.cpp")
sourceCpp("../src/geometric_features_optimized_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
time_taken <- system.time({
features <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.15,
Verticality = TRUE,
num_threads = 10
)
})
print(time_taken)
# Calculate features within radius of 2 units
time_taken <- system.time({
features <- geometric_features_knn(
points = as.matrix(tree),
k = 30,
Verticality = TRUE,
num_threads = 10
)
})
print(time_taken)
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_ultre_dist.cpp")
sourceCpp("../src/geometric_features_optimized_ultre_knn.cpp")
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_ultra_dist.cpp")
sourceCpp("../src/geometric_features_optimized_ultra_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
library(Rcpp)
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_ultra_dist.cpp")
sourceCpp("../src/geometric_features_optimized_ultra_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
time_taken <- system.time({
features_dist <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.155,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 10
)
})
print(time_taken)
summary(features_dist)
write.table(features_dist, "../data/treeFeatures_dist.txt", row.names = FALSE)
# Calculate features within radius of 2 units
time_taken <- system.time({
features_knn <- geometric_features_knn(
points = as.matrix(tree),
k = 30,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 10
)
})
print(time_taken)
summary(features_knn)
write.table(features_knn, "../data/treeFeatures_knn.txt", row.names = FALSE)
cat("\nTest completed successfully!\n")
treeFeatures_CC <- read.table("../data/treeFeatures_CC.txt", header = TRUE)
plot(density(features$Verticality, na.rm = TRUE), col = 2, lwd = 3)
treeFeatures_CC <- read.table("../data/treeFeatures_CC.txt", header = TRUE)
plot(density(features$Verticality, na.rm = TRUE), col = 2, lwd = 3)
plot(density(features_dist$Verticality, na.rm = TRUE), col = 2, lwd = 3)
lines(density(features_knn$Verticality), col = 3, lwd=3, lty = 2)
lines(density(treeFeatures_CC$Verticality_.0.155122., na.rm = TRUE), col = 4, lwd=3, lty = 3)
legend(x = "topleft",
legend = c("Dist", "Knn", "CloudCompare"),
lwd = 3, col = c(2, 3, 4), lty = c(1, 2, 3), bty = "n")
plot(density(features_dist$Planarity, na.rm = TRUE), col = 2, lwd = 3)
lines(density(features_knn$Planarity), col = 3, lwd=3, lty = 2)
lines(density(treeFeatures_CC$Planarity_.0.155122., na.rm = TRUE), col = 4, lwd=3, lty = 3)
legend(x = "topleft",
legend = c("Dist", "Knn", "CloudCompare"),
lwd = 3, col = c(2, 3, 4), lty = c(1, 2, 3), bty = "n")
plot(density(features_dist$Surface_variation, na.rm = TRUE), col = 2, lwd = 3)
lines(density(features_knn$Surface_variation), col = 3, lwd=3, lty = 2)
lines(density(treeFeatures_CC$Surface_variation_.0.155122., na.rm = TRUE), col = 4, lwd=3, lty = 3)
legend(x = "topleft",
legend = c("Dist", "Knn", "CloudCompare"),
lwd = 3, col = c(2, 3, 4), lty = c(1, 2, 3), bty = "n")
library(Rcpp)
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_ultra_dist.cpp")
sourceCpp("../src/geometric_features_optimized_ultra_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
time_taken <- system.time({
features_dist <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.155,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 10
)
})
print(time_taken)
summary(features_dist)
features_dist <- features_dist[features_dist$Verticality > 0.7, ]
write.table(features_dist, "../data/treeFeatures_dist_1.txt", row.names = FALSE)
time_taken <- system.time({
features_dist <- geometric_features_dist(
points = as.matrix(features_dist[, c("point", "x", "y", "z")]),
dist = 0.155,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 10
)
})
features_dist <- features_dist[features_dist$Verticality > 0.7, ]
write.table(features_dist, "../data/treeFeatures_dist_2.txt", row.names = FALSE)
setwd("G:/My Drive/GeometricFeatures/R")
library(Rcpp)
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_ultra_dist_v2.cpp")
sourceCpp("../src/geometric_features_optimized_ultra_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
# The plot file is here: https://drive.google.com/file/d/1GszdG8J9cRZsTtRkd80HQ_a7u10uxhKd/view?usp=sharing
plot <- read.table("../data/plot.txt", header = TRUE)
time_taken <- system.time({
features_dist <- geometric_features_dist(
points = as.matrix(plot),
dist = 0.155,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 20
)
})
print(time_taken)
# Compile the C++ code
sourceCpp("../src/geometric_features_optimized_ultra_dist.cpp")
time_taken <- system.time({
features_dist <- geometric_features_dist(
points = as.matrix(plot),
dist = 0.155,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 20
)
})
print(time_taken)
setwd("G:/My Drive/GeometricFeatures/R")
library(Rcpp)
# Compile the C++ code
sourceCpp("../src/geometric_features_dist.cpp")
sourceCpp("../src/geometric_features_knn.cpp")
# Load dataset
tree <- read.table("../data/tree.txt", header = TRUE)
time_taken <- system.time({
features_dist <- geometric_features_dist(
points = as.matrix(plot),
dist = 0.155,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 10
)
})
time_taken <- system.time({
features_dist <- geometric_features_dist(
points = as.matrix(tree),
dist = 0.155,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 10
)
})
print(time_taken)
summary(features_dist)
# Calculate features within radius of 2 units
time_taken <- system.time({
features_knn <- geometric_features_knn(
points = as.matrix(tree),
k = 30,
Verticality = TRUE,
Surface_variation = TRUE,
Planarity = TRUE,
num_threads = 10
)
})
print(time_taken)
summary(features_knn)
